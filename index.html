<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Estudo de Viabilidade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- O GLTFLoader não é mais necessário para o modelo procedural, mas pode ser reativado se você usar um modelo .gltf -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-200 */
        }
        #viewer-3d {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }
        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="overflow-hidden h-screen">

    <div class="flex flex-col h-full">
        <!-- Header -->
        <header class="bg-gray-800/50 backdrop-blur-sm border-b border-gray-700 p-4 shadow-lg z-10">
            <h1 id="project-title" class="text-xl md:text-2xl font-bold text-white">Estudo de Viabilidade - Projeto Residencial XYZ</h1>
        </header>

        <!-- Main Content -->
        <main class="flex-grow flex flex-col md:flex-row overflow-hidden">
            
            <!-- 3D Viewer Column -->
            <div id="viewer-container" class="w-full md:w-2/3 h-1/2 md:h-full bg-gray-900 relative">
                <canvas id="viewer-3d"></canvas>
                <div class="absolute top-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded">
                    Use o mouse para interagir: Orbitar (botão esquerdo), Zoom (scroll), Pan (botão direito)
                </div>
                 <div id="loader" class="absolute inset-0 flex items-center justify-center bg-gray-900/80">
                    <div class="text-center">
                        <svg class="animate-spin h-8 w-8 text-white mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p class="mt-2">Gerando modelo 3D...</p>
                    </div>
                </div>
            </div>

            <!-- Dashboard Column -->
            <aside class="w-full md:w-1/3 h-1/2 md:h-full bg-gray-800 p-4 overflow-y-auto">
                <div class="space-y-6">
                    <!-- Key Numbers -->
                    <div>
                        <h2 class="text-lg font-semibold text-cyan-400 border-b border-cyan-400/30 pb-2 mb-3">Indicadores Chave</h2>
                        <div id="key-indicators" class="grid grid-cols-2 gap-4 text-center">
                            <!-- Data will be populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Area Distribution Chart -->
                    <div>
                        <h2 class="text-lg font-semibold text-cyan-400 border-b border-cyan-400/30 pb-2 mb-3">Distribuição de Área</h2>
                        <div class="chart-container bg-gray-900/50 p-2 rounded-lg">
                            <canvas id="area-chart"></canvas>
                        </div>
                    </div>

                    <!-- Feasibility Metrics Chart -->
                    <div>
                        <h2 class="text-lg font-semibold text-cyan-400 border-b border-cyan-400/30 pb-2 mb-3">Métricas de Viabilidade</h2>
                        <div class="chart-container bg-gray-900/50 p-2 rounded-lg">
                            <canvas id="metrics-chart"></canvas>
                        </div>
                    </div>

                     <!-- Instructions -->
                    <div>
                        <h2 class="text-lg font-semibold text-gray-400 border-b border-gray-400/30 pb-2 mb-3">Sobre os Dados</h2>
                        <p class="text-sm text-gray-400">
                            Estes dados são gerados a partir do modelo paramétrico no Grasshopper e Revit. As informações representam a viabilidade econômica e de aproveitamento do terreno para a opção de design atual.
                        </p>
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <script type="module">
        // --- INÍCIO DA CONFIGURAÇÃO DE DADOS DO PROJETO ---
        const projectData = {
            projectName: "Edifício Delta - Estudo de Viabilidade",
            indicators: [
                { label: 'Área Total', value: 3000, unit: 'm²' },
                { label: 'Área Privativa', value: 1500, unit: 'm²' },
                { label: 'VGV Estimado', value: 12, unit: 'M BRL' },
                { label: 'Custo da Obra', value: 7.5, unit: 'M BRL' },
                { label: 'Nº de Unidades', value: 84, unit: 'un' },
                { label: 'Eficiência', value: 50, unit: '%' }
            ],
            areaDistribution: {
                labels: ['Privativa', 'Comum', 'Garagem', 'Circ./Téc.'],
                data: [1500, 600, 300, 600] // m²
            },
            feasibilityMetrics: {
                labels: ['Custo/m²', 'Venda/m²', 'Lucro/m²'],
                data: [2500, 8000, 3000] // Values in BRL
            },
            // Se modelPath for deixado em branco, um modelo procedural será gerado.
            // Para usar um modelo GLTF/GLB, reative o GLTFLoader.js no <head> e coloque a URL aqui.
            modelPath: ''
        };
        // --- FIM DA CONFIGURAÇÃO DE DADOS DO PROJETO ---


        // --- LÓGICA DA APLICAÇÃO ---

        // Populate dynamic content
        document.getElementById('project-title').textContent = projectData.projectName;
        
        const indicatorsContainer = document.getElementById('key-indicators');
        projectData.indicators.forEach(item => {
            const indicatorEl = document.createElement('div');
            indicatorEl.className = 'bg-gray-700 p-3 rounded-lg';
            indicatorEl.innerHTML = `
                <div class="text-2xl font-bold text-white">${item.value.toLocaleString('pt-BR')}</div>
                <div class="text-xs text-gray-400">${item.label} (${item.unit})</div>
            `;
            indicatorsContainer.appendChild(indicatorEl);
        });

        // Chart.js Global Config
        Chart.defaults.color = '#d1d5db'; // text-gray-300
        Chart.defaults.borderColor = 'rgba(255, 255, 255, 0.1)';

        // Area Distribution Chart (Pie)
        new Chart(document.getElementById('area-chart'), {
            type: 'doughnut',
            data: {
                labels: projectData.areaDistribution.labels,
                datasets: [{
                    label: 'Área (m²)',
                    data: projectData.areaDistribution.data,
                    backgroundColor: [
                        'rgba(59, 130, 246, 0.7)',  // blue-500
                        'rgba(16, 185, 129, 0.7)',  // emerald-500
                        'rgba(239, 68, 68, 0.7)',   // red-500
                        'rgba(249, 115, 22, 0.7)'   // orange-500
                    ],
                    borderColor: '#1f2937',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 15,
                            boxWidth: 12
                        }
                    }
                }
            }
        });

        // Feasibility Metrics Chart (Bar)
        new Chart(document.getElementById('metrics-chart'), {
            type: 'bar',
            data: {
                labels: projectData.feasibilityMetrics.labels,
                datasets: [{
                    label: 'Valor (BRL)',
                    data: projectData.feasibilityMetrics.data,
                    backgroundColor: 'rgba(22, 163, 74, 0.6)', // green-600
                    borderColor: 'rgba(22, 163, 74, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                             callback: function(value) {
                                return 'R$ ' + value.toLocaleString('pt-BR');
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
        
        // Three.js 3D Viewer
        let scene, camera, renderer, controls;
        const container = document.getElementById('viewer-container');
        const canvas = document.getElementById('viewer-3d');
        const loaderElement = document.getElementById('loader');

        // Função para criar o prédio proceduralmente
        function createProceduralBuilding() {
            const buildingGroup = new THREE.Group();

            // Materiais
            const parkingMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.8 });
            const commonAreaMaterial = new THREE.MeshStandardMaterial({ color: 0x718096, transparent: true, opacity: 0.9, roughness: 0.5 });
            const flatMaterial = new THREE.MeshStandardMaterial({ color: 0xE2E8F0, metalness: 0.1, roughness: 0.3 });
            const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            const poolMaterial = new THREE.MeshStandardMaterial({ color: 0x38B2AC });
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x166534, side: THREE.DoubleSide });

            const floorHeight = 3; // 3 metros
            const buildingWidth = 10; // Terreno 20m - 5m recuo esq - 5m recuo dir
            const buildingDepth = 30; // Terreno 40m - 5m recuo frente - 5m recuo fundo
            
            // Plano do terreno
            const groundGeo = new THREE.PlaneGeometry(20, 40);
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            buildingGroup.add(ground);

            let currentY = 0;

            // 1 Subsolo (representado como base)
            const baseGeo = new THREE.BoxGeometry(buildingWidth, floorHeight, buildingDepth);
            const base = new THREE.Mesh(baseGeo, parkingMaterial);
            currentY = floorHeight / 2;
            base.position.y = currentY;
            buildingGroup.add(base);

            // Térreo (Áreas Comuns)
            currentY += floorHeight;
            const terreoGeo = new THREE.BoxGeometry(buildingWidth, floorHeight, buildingDepth);
            const terreo = new THREE.Mesh(terreoGeo, commonAreaMaterial);
            terreo.position.y = currentY - (floorHeight / 2);
            buildingGroup.add(terreo);

            // 7 Pavimentos de Flats
            for (let i = 0; i < 7; i++) {
                const flatGeo = new THREE.BoxGeometry(buildingWidth, floorHeight, buildingDepth);
                const flatFloor = new THREE.Mesh(flatGeo, flatMaterial);
                flatFloor.position.y = currentY + (i * floorHeight) + (floorHeight / 2);
                buildingGroup.add(flatFloor);
            }
            currentY += 7 * floorHeight;

            // Cobertura com piscina
            const roofGeo = new THREE.BoxGeometry(buildingWidth, floorHeight / 2, buildingDepth);
            const roof = new THREE.Mesh(roofGeo, roofMaterial);
            roof.position.y = currentY + (floorHeight / 4);
            buildingGroup.add(roof);

            const poolGeo = new THREE.BoxGeometry(buildingWidth * 0.4, floorHeight / 4, buildingDepth * 0.3);
            const pool = new THREE.Mesh(poolGeo, poolMaterial);
            pool.position.y = currentY + (floorHeight / 2); // Em cima da laje da cobertura
            buildingGroup.add(pool);
            
            return buildingGroup;
        }

        function init3D() {
            // Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            // Câmera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(30, 25, 40);

            // Renderizador
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;

            // Controles
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 150;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Iluminação
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(20, 30, 15);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-20, -10, -15);
            scene.add(directionalLight2);
            
            // Grid
            const gridHelper = new THREE.GridHelper(50, 10, 0x444444, 0x333333);
            scene.add(gridHelper);

            // Lógica do Modelo
            if (!projectData.modelPath) {
                // Gera o modelo procedural se o caminho estiver vazio
                const model = createProceduralBuilding();
                scene.add(model);
                loaderElement.style.display = 'none'; // Esconde o loader
            } else {
                // TODO: Adicionar lógica para GLTFLoader se um caminho for fornecido
                console.error("Para carregar um modelo GLTF, reative o script GLTFLoader.js e a lógica de carregamento.");
                loaderElement.innerHTML = '<p class="text-yellow-500">Configurado para usar modelo GLTF, mas a lógica está desativada.</p>'
            }

            // Lidar com redimensionamento da janela
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init3D();
        animate();
    </script>
</body>
</html>

